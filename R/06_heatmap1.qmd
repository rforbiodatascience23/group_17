---
title: "06_heatmap1"
format: html
editor: visual
---

# Clustering analysis with all proteomics data

## Hierachial clustering visualised in a heatmap

```{r}
#| echo: false
#| label: load packages

library(tidyverse)

#if (!require('ggendro', character.only = TRUE)) {
  # If not installed, install the package
#  install.packages('ggdendro')
#}
library(ggdendro)
library(grid)
library(patchwork)
clinical_data <- read.table("../data/clinical_data.tsv", sep = "\t", header = T)
cm <- read.table("../data/count_matrix_1_77.tsv", header = T)
```

```{r}
#| label: load data (and augment)

cm <- cm |>
  pivot_longer(cols = -id, names_to = 'variable', values_to = 'value') |> # Converting ot pivot_longer
  pivot_wider(names_from = id, values_from = value) |> # Converting the longer data to a wider data with names from id, and values from value
  rename(id = variable) |> # renaming variable to id
  column_to_rownames('id') # Converting the id column to rownames


```

Hierachial clustering and dendogramming

```{r}
#| label: hierachial clustering

# create distance matrix (scaled) and perform hierachial clustering
hc <- cm |>
  dist() |> # calculating the distance for each value
  hclust(method = "complete")  # applying the hierachial clustering algorithm to the data 

# save clustering as dendogram
ddg <- as.dendrogram(hc)
  
# extract dendogram order
ddg_order <- order.dendrogram(ddg)
  
# extract all dendro information
ddg_data <- dendro_data(ddg)

# add pam50 information to ddg_data
ddg_label <- label(ddg_data) |>
  rename(id = label) |> 
  left_join(clinical_data, by = c("id")) |> 
  select(x,y, id, pam50)


# create dendogram plot based on hierachial clustering
ddg_plot <- ggdendrogram(data = hc, rotate=T) +
  theme(axis.text.y = element_blank(), # removing labels on x axis
        axis.text.x = element_blank()) + # removing labels on Y axis
  geom_text(data=ddg_label,
            aes(label=id, x=x, y=-15, colour=pam50), # labels on y axis colored by pam50. 
            size = 2)

ddg_plot
```

heatmapping by order of clustering

```{r}
#| label: visualization


# define long data structure based on the count matrix
cm_long <- cm |> 
  rownames_to_column(var = "id") |> # setting rownames to a column named id
  pivot_longer(cols = -c("id"), names_to = "protein") |>  # converting to pivot longer
  mutate(id = factor(x = id, levels = unique(id) |> reorder(ddg_order), ordered = T)) # Factorize the id column based on unique values from id ordered by the ddg_order

# heatmap on scaled data:
hm <- ggplot(data = cm_long, mapping = aes(x = protein, y = id)) +
        geom_tile(aes(fill=value)) + # heatmap function
        scale_fill_gradient2(low = "red", high = "blue") + # scale color (high values are blue, low values are red)
        theme_minimal() + 
        theme(axis.text.x = element_blank(), # remove label on x axis
              axis.text.y = element_text(size = 5),
              legend.position = "left") # position of the legend on the left
hm


# Extract relevant columns from clinical_data
selected_data <- clnical_data |> 
  select("id", "pam50") # id and pam50 from the clinical data. 

# Define color mapping for pam50 values
color_mapping <- data.frame(
  pam50 = c("Basal-like", "HER2-enriched", "Luminal A", "Luminal B"),
  color = c("red", "blue", "green", "purple") # each element in the pam50 has been given a color
)

# Merge selected_data with color_mapping
merged_color_data <- left_join(selected_data, color_mapping, by = "pam50") |>  #mergning the selected_data and color_mapping dataset by pam50
  mutate(id = factor(merged_color_data |> pull(id), # converting the ID column to factor
                     levels = unique(merged_color_data |> pull(id))))

hm <- ggplot(data = cm_long, mapping = aes(x = protein, y = id)) +
  geom_tile(aes(fill = value)) + # heatmap function
  scale_fill_gradient2(low = "red", high = "blue")+ # low values are red, high values are blue
  scale_y_discrete(labels = merged_color_data |> pull("id")) +  # Set y-axis labels
  theme(
    axis.text.x = element_blank(),# remove x-axis
    axis.text.y = element_text(size = 5),
    legend.position = "left"
  )

```

Print the two plots side-by-side using patchwork:

```{r}
hm + ddg_plot 
```
