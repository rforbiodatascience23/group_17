---
title: "Differential gene expression analysis"
format: html
editor: visual
---

```{r}
library(tidyverse)
```

Load data:

```{r}

protein_data <- read.table("../data/count_matrix_1_77.tsv", header = T)|>
      #Load the count matrix
  pivot_longer(cols = -id, names_to = 'variable', values_to = 'value') |>
      #Pivot longer. First step in transposing the matrix. 
  pivot_wider(names_from = id, values_from = value) |>
      #Pivot wider - second step in transposing the matrix
  rename(id = variable)
      #Rename the column 'variable' to 'id'

clinical_data <- read.table("../data/clinical_data.tsv", sep = "\t", header = T)
      #Read the clinial data
```

Wrangling the data into something which we can use in

```{r}

full_data <- clinical_data |>
  mutate( 
    DGEA_HER2 = case_when(
      pam50 == "HER2-enriched" ~ 1, 
      TRUE ~ 0
    ), # ^ Make a new column called 'DGEA_HER2' storing binary information of 
       # whether the individual is positive (1) or negative (0) for HER2
    DGEA_Luminal_A = case_when(
      pam50 == "Luminal A" ~ 1, 
      TRUE ~ 0
  ),   # ^ Make a new column called 'DGEA_Luminal_A' storing binary information of 
       # whether the individual is positive (1) or negative (0) for Luminal A
    DGEA_Luminal_B = case_when(
      pam50 == "Luminal B" ~ 1, 
      TRUE ~ 0
      ),# ^ Make a new column called 'DGEA_Luminal_B' storing binary information of 
       # whether the individual is positive (1) or negative (0) for Luminal B
    DGEA_Basal_like = case_when(
      pam50 == "Basal-like" ~ 1, 
      TRUE ~ 0)) |>
        # ^ Make a new column called 'DGEA_Basal_like' storing binary information of 
       # whether the individual is positive (1) or negative (0) for Basal like
  left_join(protein_data, by = "id")
        # Leftjoin the protein expression data to make a big dataframe with everything



```

In the following, the actual gene expression analysis takes place. 4 analyses are made - one for each subtype of PAM50. Each subtype is compared to all the rest of the data. Thus, almost the same code is used 4 times. For HER2, each step is described.

```{r}

#HER2 positive
HER2 <- full_data |>
  select(c(DGEA_HER2, starts_with("NP"))) |>
      # Select only the protein data and the column storing information on 
      # whether a person is the HER2 group of not (binary)
  pivot_longer(cols = starts_with("NP"),
               names_to = "protein",
               values_to = "value") |>
      # Pivot longer, listing each protein under one another
  group_by(protein) |>
      # Group by protein
  nest() |> 
      # Nest according to the grouping. Data is now nested by proteins. 
  mutate(LM = map(.x = data,
                  .f = ~lm(formula = DGEA_HER2 ~ value,
                            data = .x))) |>
      # Take one nested dataframe (one protein) at a time and run a linear model 
      # where the protein value is the independent variable, and the HER2-status
      # is the dependent variable.
      # store the result in a column in the mother-dataframe called "LM"
      # The results are now stored in lists nested in the mother dataframe. 
  mutate(LM_tidy = map(.x = LM,
                          .f = ~broom::tidy(x = .x,
                                     conf.int = TRUE,
                                     conf.level = 0.95))) |>
      # Unpack the results from the linear models. Store them in a column 
      # called 'LM_tidy'
  unnest(LM_tidy) |>
      # Unpack the results into the mother dataframe for easier readability
  filter(term == "value") |>
      # Filter the columns to include only "value". This is done because the last
      # line of code gave 2 rows of results for each protein - one for intercept
      # and one for protein. We are only interested in the protein.
  select(-c(data, LM, term)) |>
      # Deselect the column storing the raw protein data to only have the results left
  mutate(adjusted_BH = p.adjust(p.value, n = 12554, method = "BH"), 
            # Benjamini hichberg adjustment for multiple comparisons
         adjusted_fdr = p.adjust(p.value, n = 12554, method = "fdr"), 
            # False discrovery rate adjustment for multiple comparisons
         log2 = -log2(p.value)) |>
            # -log2 transformation of the p-values for use in the vizualisation below
    arrange(p.value)
            # arrange data according to best adjusted p-values


#Luminal A
Luminal_A <- full_data |>
  select(c(DGEA_Luminal_A, starts_with("NP"))) |>
  pivot_longer(cols = starts_with("NP"),
               names_to = "protein",
               values_to = "value") |>
  group_by(protein) |>
  nest() |> 
  mutate(LM = map(.x = data,
                  .f = ~lm(formula = DGEA_Luminal_A ~ value,
                            data = .x))) |>
  mutate(LM_tidy = map(.x = LM,
                          .f = ~broom::tidy(x = .x,
                                     conf.int = TRUE,
                                     conf.level = 0.95))) |>
  unnest(LM_tidy) |>
  filter(term == "value") |>
  select(-c(data, LM, term)) |>
  mutate(adjusted_BH = p.adjust(p.value, n = 12554, method = "BH"), 
         adjusted_fdr = p.adjust(p.value, n = 12554, method = "fdr")) |>
  arrange(p.value)

#Luminal B
Luminal_B <- full_data |>
  select(c(DGEA_Luminal_B, starts_with("NP"))) |>
  pivot_longer(cols = starts_with("NP"),
               names_to = "protein",
               values_to = "value") |>
  group_by(protein) |>
  nest() |> 
  mutate(LM = map(.x = data,
                  .f = ~lm(formula = DGEA_Luminal_B ~ value,
                            data = .x))) |>
  mutate(LM_tidy = map(.x = LM,
                          .f = ~broom::tidy(x = .x,
                                     conf.int = TRUE,
                                     conf.level = 0.95))) |>
  unnest(LM_tidy) |>
  filter(term == "value") |>
  select(-c(data, LM, term)) |>
  mutate(adjusted_BH = p.adjust(p.value, n = 12554, method = "BH"), 
         adjusted_fdr = p.adjust(p.value, n = 12554, method = "fdr")) |>
  arrange(p.value)


#Basal like
Basal_like <- full_data |>
  select(c(DGEA_Basal_like, starts_with("NP"))) |>
  pivot_longer(cols = starts_with("NP"),
               names_to = "protein",
               values_to = "value") |>
  group_by(protein) |>
  nest() |> 
  mutate(LM = map(.x = data,
                  .f = ~lm(formula = DGEA_Basal_like ~ value,
                            data = .x))) |>
  mutate(LM_tidy = map(.x = LM,
                          .f = ~broom::tidy(x = .x,
                                     conf.int = TRUE,
                                     conf.level = 0.95))) |>
  unnest(LM_tidy) |>
  filter(term == "value") |>
  select(-c(data, LM, term)) |>
  mutate(adjusted_BH = p.adjust(p.value, n = 12554, method = "BH"), 
         adjusted_fdr = p.adjust(p.value, n = 12554, method = "fdr")) |>
  arrange(p.value)
```

Save:

```{r}
# Save the results for easy import into next steps of the analysis.
write_tsv(HER2, "../data/diff_exp_HER2.tsv")
write_tsv(Luminal_A, "../data/diff_exp_Luminal_A.tsv")
write_tsv(Luminal_B, "../data/diff_exp_Luminal_B.tsv")
write_tsv(Basal_like, "../data/diff_exp_Basal_like.tsv")
```
